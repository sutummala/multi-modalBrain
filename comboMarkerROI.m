function comboMarkerROI

% Created on Sep 2015 by Tummala. It creates Combinationl Map based on
% several Individual maps, ROI based level. The combinational Map would be generated by
% using Linear Discriminant Analysis

addpath C:\Matlab\spm12
addpath E:\Analysis-Sudhakar\Matlab

roipath = 'E:\Analysis-Sudhakar\OSAMT\ROIs'; % path to predefined ROIs. This is useful when doing regional Combo Marker estimation
roifiles = dir(roipath);

savepath = 'E:\Analysis-Sudhakar\ComboMarker\COMBO'; % The path to save the combinational marker maps


MKdatapath = 'E:\Analysis-Sudhakar\ComboMarker\MK';
MKdata = dir(MKdatapath);

MTdatapath = 'E:\Analysis-Sudhakar\ComboMarker\MT';
MTdata = dir(MTdatapath);

T1byT2datapath = 'E:\Analysis-Sudhakar\ComboMarker\Texture';
T1byT2data = dir(T1byT2datapath);

Healthy = 25; % Number of healthy subjects
OSA = 17; % Number of OSA subjects

brainmask = spm_read_vols(spm_vol('C:\Matlab\spm12\tpm\rlabels_Neuromorphometrics.nii')); % You can change the masking here, whole brain (or) gray matter (or) white matter. Whole Brain is time consuming
Vi = spm_vol('E:\Analysis-Sudhakar\DKI-Analysis\Brainmask\brainmask.nii');

[x, y, z] = size(brainmask); 
helMK = []; osaMK = []; helMT = []; osaMT = []; helT1byT2 = []; osaT1byT2 = [];
comboMap = struct('map', zeros(size(brainmask))); 
ROI = 1; % Choose 1 for Regional ComboMarker, 0 for voxel-by-voxel combo analysis

%if ROI, x = 1; y = 1; z = 1; end % Used in ROI analysis
    
%                     for r = 4:2:length(roifiles) % It does ROI based Analysis
%                         fprintf('ROI is %s\n', roifiles(r).name);
                for r = 1:max(brainmask(:))
                     if find(r == unique(brainmask(:)))
                          fprintf('ROI is %d\n', r); 
                    for i = 3:length(MKdata) % Extracting MK data
                        data = spm_read_vols(spm_vol([MKdatapath, '\', MKdata(i).name]));
                         if i <= Healthy + 2
                             if ROI % region level
                                 %roimap = spm_read_vols(spm_vol([roipath, '\', roifiles(r).name]));
                                 helMK(end+1) = mean(data(brainmask == r));
                             else
                                 helMK(end+1) = data(a, b, c); % Voxel level
                             end
                         else
                             if ROI
                                 %roimap = spm_read_vols(spm_vol([roipath, '\', roifiles(r).name]));
                                 osaMK(end+1) = mean(data(brainmask == r));
                             else
                                 osaMK(end+1) = data(a, b, c);
                             end
                         end
                    end
                    %-----------------------------------------------------------------------------------------------------------
                    for j = 3:length(MTdata) % Extracting MT data
                        data1 = spm_read_vols(spm_vol([MTdatapath, '\', MTdata(j).name]));
                        if j <= Healthy + 2
                            if ROI % region level
                                 %roimap = spm_read_vols(spm_vol([roipath, '\', roifiles(r).name]));
                                 helMT(end+1) = mean(data1(brainmask == r));
                            else
                                 helMT(end+1) = data1(a, b, c);
                            end
                        else
                            if ROI % region level
                                 %roimap = spm_read_vols(spm_vol([roipath, '\', roifiles(r).name]));
                                 osaMT(end+1) = mean(data1(brainmask == r));
                            else
                                 osaMT(end+1) = data1(a, b, c);
                            end
                        end
                    end
                    %------------------------------------------------------------------------------------------------------------
                    for k = 3:length(T1byT2data) % Extracting T1byT2 data
                        data2 = spm_read_vols(spm_vol([T1byT2datapath, '\', T1byT2data(k).name]));
                        if k <= Healthy + 2
                            if ROI % region level
                                 %roimap = spm_read_vols(spm_vol([roipath, '\', roifiles(r).name]));
                                 helT1byT2(end+1) = mean(data2(brainmask == r));
                            else
                                 helT1byT2(end+1) = data2(a, b, c);
                            end
                        else
                            if ROI % region level
                                 %roimap = spm_read_vols(spm_vol([roipath, '\', roifiles(r).name]));
                                 osaT1byT2(end+1) = mean(data2(brainmask == r));
                            else
                                 osaT1byT2(end+1) = data2(a, b, c);
                            end
                        end
                    end
                    combo = doLDA(helMK, osaMK, helMT, osaMT, helT1byT2, osaT1byT2, Healthy, OSA); % This function does combinational marker estimation at each voxel location
                    helMK = []; osaMK = []; helMT = []; osaMT = []; helT1byT2 = []; osaT1byT2 = []; % Reinitialize the arrays for every voxel 
                    % The following lines writes values to the
                    % corresponding subject at the corresponding voxel location
                    if ~ROI
                        for s = 1:length(combo)
                            comboMap(s).map(a, b, c) = combo(s);
                        end
                    end
                   end
                end
   
close(h)
save comboMap

% Writing the maps to Nifti, if doing voxel-by-voxel.

if ~ROI
    for p = 1:length(combo)
        filename = [savepath, '\', ['m', MTdata(p+2).name(4:10), 'ComboMarkerMap', '.nii']];
        Vo = struct('fname', filename,'dim',Vi(1).dim(1:3),'dt',[spm_type('float32'), 0],'mat', Vi(1).mat,'pinfo',[1.0,0,0]','descrip',	'ComboMarkerMap');
        Vo = spm_create_vol(Vo);
        spm_write_vol(Vo, comboMap(p).map) % Writing the Maps to Nifti, which would be used for further Group Analysis
    end
end

function combo = doLDA(helMK, osaMK, helMT, osaMT, helt, osat, H, O)

ev = Evaluate; 

[p1, h] = ranksum(helMK, osaMK);
fprintf('p-value for MK is %1.9f\n', p1);
[p2, h] = ranksum(helMT, osaMT);
fprintf('p-value for MT is %1.9f\n', p2);
[p3, h] = ranksum(helt, osat);
fprintf('p-value for T1byT2 is %1.9f\n', p3);

% Doing LDA/Linear Regression for developing the Combinational marker. If
% data follows gaussian distribution use LDA, otherwise prefer Regression
for t = 1:2
    if t == 1
        Hel(:, 1) = helMK./std([helMK osaMK]); Hel(:, 2) = helMT./std([helMT osaMT]); Hel(:, 3) = helt./std([helt osat]); % Rescaling the values to have std of one/Healthy
        Osa(:, 1) = osaMK./std([helMK osaMK]); Osa(:, 2) = osaMT./std([helMT osaMT]); Osa(:, 3) = osat./std([helt osat]); % Rescaling the values to have std of one/Diseased
        w = LDA(ev, Hel, Osa); % LDA
        combo = abs(w(1) * [Hel(:, 1); Osa(:, 1)] + w(2) * [Hel(:, 2); Osa(:, 2)] + w(3) * [Hel(:, 3); Osa(:, 3)]);
        % Validating the combinational marker
        [pLDA, h] = ranksum(combo(1:H), combo(H + 1: H + O));
        fprintf('p-value based on LDA is %1.9f\n', pLDA);
    else
        data = [[helMK osaMK]' [helMT osaMT]' [helt osat]'];
        ca = [ones(H, 1); zeros(O, 1)];
        mdl = fitlm(data, ca, 'linear','RobustOpts','on'); % Linear Regression
        combo = abs(mdl.Coefficients{1, 1} + mdl.Coefficients{2,1} * [helMK osaMK] + mdl.Coefficients{3,1} * [helMT osaMT] + mdl.Coefficients{4,1} * [helt osat]);
        % Validating the combinational marker
        [preg, h] = ranksum(combo(1:H), combo(H + 1: H + O));
        fprintf('p-value based on Regression is %1.9f\n\n', preg);
    end
end
combo = combo./max(combo);

if pLDA < preg
    fprintf('LDA performed better than Regression\n\n');
else
    fprintf('Regression performed better than LDA\n\n');
end

