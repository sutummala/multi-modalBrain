function comboMarker2

% Created on Sep 2015 by Tummala. It creates Combinationl Map based on
% several Individual maps, voxel level. The combinational Map would be generated by
% using Linear Discriminant Analysis

addpath C:\Matlab\spm12
addpath E:\Analysis-Sudhakar\Matlab

savepath = 'E:\Analysis-Sudhakar\ComboMarker\COMBOAKRK'; % The path to save the combinational marker maps

if ~exist(savepath)
    mkdir(savepath);
end

MKdatapath = 'E:\Analysis-Sudhakar\ComboMarker\AK'; % Axial Kurtosis, Axonal injury
MKdata = dir(MKdatapath);

MTdatapath = 'E:\Analysis-Sudhakar\ComboMarker\RK'; % Magnetization Transfer, Myelin injury/Bound water
MTdata = dir(MTdatapath);

Healthy = 26; % Number of healthy subjects
OSA = 22; % Number of OSA subjects

brainmask = spm_read_vols(spm_vol('E:\Analysis-Sudhakar\DKI-Analysis\Brainmask\brainmask.nii')); % You can change the masking here, whole brain (or) gray matter (or) white matter. 
Vi = spm_vol('E:\Analysis-Sudhakar\DKI-Analysis\Brainmask\brainmask.nii');

[x, y, z] = size(brainmask); 
helMK = []; osaMK = []; helMT = []; osaMT = []; 
comboMap = struct([]); 
M1 = struct('data', zeros(size(brainmask))); M2 = struct('data', zeros(size(brainmask))); M3 = struct('data', zeros(size(brainmask))); M4 = struct('data', zeros(size(brainmask)));

for n = 3:length(MKdata) % Converting the maps into a structure to facilitate faster processing
    data = spm_read_vols(spm_vol([MKdatapath, '\', MKdata(n).name]));
    data1 = spm_read_vols(spm_vol([MTdatapath, '\', MTdata(n).name]));
%     data2 = spm_read_vols(spm_vol([T1byT2datapath, '\', T1byT2data(n).name]));
%     data3 = spm_read_vols(spm_vol([T2stardatapath, '\', T2stardata(n).name]));
    M1(n).data = data;
    M2(n).data = data1;
%     M3(n).data = data2;
%     M4(n).data = data3;
    clear data data1 
end
fprintf('All the data was converted into Structures\n\n');
        
for a = 1:x
    h = waitbar(a/x); % Gives information about progress 
     for b = 1:y
          for c = 1:z
                if brainmask(a, b, c) 
                    fprintf('==================================================================================================\n');
                    fprintf('For voxel location %d %d %d\n', a, b, c);
                    for i = 3:length(MKdata) % Extracting the data, voxel-wise
                         if i <= Healthy + 2
                              helMK(end+1) = M1(i).data(a, b, c);
                              helMT(end+1) = M2(i).data(a, b, c);
%                               helT1byT2(end+1) = M3(i).data(a, b, c);
%                               helT2s(end+1) = M4(i).data(a, b, c);
                         else
                              osaMK(end+1) = M1(i).data(a, b, c);
                              osaMT(end+1) = M2(i).data(a, b, c);
%                               osaT1byT2(end+1) = M3(i).data(a, b, c);
%                               osaT2s(end+1) = M4(i).data(a, b, c);
                         end
                    end
                %-----------------------------------------------------------------------------------------------------------
                    combo = doLDA(helMK, osaMK, helMT, osaMT, Healthy, OSA); % This function does combinational marker estimation at each voxel location
                    helMK = []; osaMK = []; helMT = []; osaMT = []; % Reinitialize the data arrays for every voxel 
                    % The following lines writes values to the
                    % corresponding subject at the corresponding voxel location   
                    for s = 1:length(combo)
                        comboMap(s).map(a, b, c) = combo(s);
                    end
                end
           end
     end
end
close(h)
save comboMap

% Writing the maps to Nifti.

for p = 1:length(combo)
    filename = [savepath, '\', ['m', MTdata(p+2).name, 'ComboMarkerMap', '.nii']];
    Vo = struct('fname', filename,'dim', size(comboMap(p).map),'dt',[spm_type('float32'), 0],'mat', Vi(1).mat,'pinfo',[1.0,0,0]','descrip',	'ComboMarkerMap');
    Vo = spm_create_vol(Vo);
    spm_write_vol(Vo, comboMap(p).map) % Writing the Maps to Nifti, which would be used for further Group Analysis
end


function combo = doLDA(helMK, osaMK, helMT, osaMT, H, O)

ev = Evaluate; 

[p1, h] = ranksum(helMK, osaMK);
fprintf('p-value for AK is %1.9f\n', p1);
[p2, h] = ranksum(helMT, osaMT);
fprintf('p-value for RK is %1.9f\n', p2);
% [p3, h] = ranksum(helt, osat);
% fprintf('p-value for Entropy is %1.9f\n', p3);
% [p4, h] = ranksum(helt2s, osat2s);
% fprintf('p-value for R2 Star is %1.9f\n', p3);

% Doing LDA/Linear Regression for developing the Combinational marker. If
% data follows gaussian distribution use LDA, otherwise prefer Regression
if 1
    Hel(:, 1) = helMK./std([helMK osaMK]); Hel(:, 2) = helMT./std([helMT osaMT]); % Hel(:, 3) = helt./std([helt osat]); Hel(:, 4) = helt2s./std([helt2s osat2s]); % Rescaling the values to have std of one/Healthy
    Osa(:, 1) = osaMK./std([helMK osaMK]); Osa(:, 2) = osaMT./std([helMT osaMT]); % Osa(:, 3) = osat./std([helt osat]); Osa(:, 4) = osat2s./std([helt2s osat2s]); % Rescaling the values to have std of one/Diseased
    w = LDA(ev, Hel, Osa) % LDA
    combo = abs(w(1) * [Hel(:, 1); Osa(:, 1)] + w(2) * [Hel(:, 2); Osa(:, 2)]); % + w(3) * [Hel(:, 3); Osa(:, 3)]) + w(4) *[Hel(:, 4); Osa(:, 4)];
else
    data = [[helMK osaMK]' [helMT osaMT]']; % [helt osat]' [helt2s osat2s]'];
    ca = [ones(H, 1); zeros(O, 1)];
    mdl = fitlm(data, ca, 'linear','RobustOpts','on'); % Linear Regression
    combo = abs(mdl.Coefficients{1, 1} + mdl.Coefficients{2,1} * [helMK osaMK] + mdl.Coefficients{3,1} * [helMT osaMT]);% + mdl.Coefficients{4,1} * [helt osat] + mdl.Coefficients{5,1} * [helt2s osat2s]);
end
combo = combo./max(combo);

% Validating the combinational marker
[pCombo, h] = ranksum(combo(1:H), combo(H + 1: H + O));
fprintf('p-value for Combo is %1.9f\n\n', pCombo);

if pCombo < p1 & pCombo < p2 % & pCombo < p3
    fprintf('Combo Marker performed better than individual markers\n\n');
end

